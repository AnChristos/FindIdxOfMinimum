#include <algorithm>
#include <benchmark/benchmark.h>
#include <random>
#include <stdlib.h>
#include <iostream>
/*
 * Alignment of  64 bytes
 */
constexpr int alignment = 64;
/*
 * create global data
 * a bit hacky way
 */
constexpr size_t nn = 8 << 10;
float* inArray;
class InitArray
{
public:
  InitArray()
  {
    std::mt19937 gen;
    std::uniform_real_distribution<> dis(1.0, 10.0);
    // create buffer of right size,properly aligned
    size_t const size = nn * sizeof(float);
    posix_memalign((void**)&inArray, alignment, size);
    for (size_t i = 0; i < nn; ++i) {
      // Use dis to transform the random unsigned int generated by gen into a
      // double. Each call to dis(gen) generates a new random double
      inArray[i] = dis(gen);
    }
  }
  ~InitArray() { free(inArray); }
};
InitArray initArray;

static void
findMinimumIndexC(benchmark::State& state)
{

  for (auto _ : state) {
    const int n = state.range(0);
    float* distances = (float*)__builtin_assume_aligned(inArray, alignment);
    int minIndex = 0; // always 1e30
    int mini2 = -1;
    float minDistance = distances[0];
    float minDistance2 = std::numeric_limits<float>::max();

    for (int i = 1; i < n; ++i) {
      if (distances[i] < minDistance) {
        mini2 = minIndex;
        minDistance2 = minDistance;
        minIndex = i;
        minDistance = distances[i];
      } else if (distances[i] < minDistance2) {
        mini2 = i;
        minDistance2 = distances[i];
      }
    }

    benchmark::DoNotOptimize(&minIndex);
    benchmark::DoNotOptimize(&mini2);
    benchmark::ClobberMemory();
    //std::cout<< " C Min 1 index "<<minIndex << " " <<minDistance<<std::endl;
    //std::cout<< " C Min 2 index "<<mini2 << " " <<minDistance2<<std::endl;
  }
}

BENCHMARK(findMinimumIndexC)->Range(64, nn);

/*
 * See if we have SSE2 or SSE4.1 supported
 * enabling newer extension also enables
 * then
 */
#if defined(__SSE4_1__) || defined(__SSE2__)
/*
 * SSE2 does not have a blend/select instruction.
 * Instruction describes in
 * https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_b&expand=431,452&techs=SSE4_1
 *
 * We AND &
 * - a with the NOT of the mask
 * - b with the mask
 * The result is the OR
 *
 */
#if defined(__SSE4_1__)
#include <smmintrin.h>
static const auto mm_blendv_epi8 = _mm_blendv_epi8;
#elif defined(__SSE2__)
#include <emmintrin.h>
static inline __m128i
SSE2_mm_blendv_epi8(__m128i a, __m128i b, __m128i mask)
{
  return _mm_or_si128(_mm_andnot_si128(mask, a), _mm_and_si128(mask, b));
}
static const auto mm_blendv_epi8 = SSE2_mm_blendv_epi8;
#endif /* on SSE4.1 vs SSE2 for the blend instructions*/
#endif  
  
static void
findMinimumIndexSSE(benchmark::State& state)
{
  for (auto _ : state) {

    const int n = state.range(0);
    float* array = (float*)__builtin_assume_aligned(inArray, alignment);
    /* Assuming SSE do 2 vectors of 4 elements in a time
     * one might want to revisit for AVX2 */
    const __m128i increment = _mm_set1_epi32(8);
    __m128i indices1 = _mm_setr_epi32(0, 1, 2, 3);
    __m128i indices2 = _mm_setr_epi32(4, 5, 6, 7);
    __m128i minindices1 = indices1;
    __m128i minindices2 = indices2;
    __m128 minvalues1 = _mm_load_ps(array);
    __m128 minvalues2 = _mm_load_ps(array + 4);

    for (int i = 8; i < n; i += 8) {
      // Load 8 elements at a time in 2 vectors of size 4
      const __m128 values1 = _mm_load_ps(array + i);     // first 4
      const __m128 values2 = _mm_load_ps(array + i + 4); // second 4
      // Handle the first 4
      indices1 = _mm_add_epi32(indices1, increment);
      __m128i lt1 = _mm_castps_si128(_mm_cmplt_ps(values1, minvalues1));
      minindices1 = mm_blendv_epi8(minindices1, indices1, lt1);
      minvalues1 = _mm_min_ps(values1, minvalues1);
      // Handle the second 4
      indices2 = _mm_add_epi32(indices2, increment);
      __m128i lt2 = _mm_castps_si128(_mm_cmplt_ps(values2, minvalues2));
      minindices2 = mm_blendv_epi8(minindices2, indices2, lt2);
      minvalues2 = _mm_min_ps(values2, minvalues2);
    }

    /*
     * Do the final calculation scalar way
     */
    alignas(alignment) float distances[8];
    alignas(alignment) int32_t indices[8];
    _mm_store_ps(distances, minvalues1);
    _mm_store_ps(distances + 4, minvalues2);
    _mm_store_si128((__m128i*)(indices), minindices1);
    _mm_store_si128((__m128i*)(indices + 4), minindices2);

    int32_t mini = indices[0]; // always 1e30
    int32_t mini2 = -1;
    float minDistance = distances[0];
    float minDistance2 = std::numeric_limits<float>::max();
    for (int i = 1; i < 8; ++i) {
      if (distances[i] < minDistance) {
        mini2 = mini;
        minDistance2 = minDistance;
        mini = indices[i];
        minDistance = distances[i];
      } else if (distances[i] < minDistance2) {
        mini2 = indices[i];
        minDistance2 = distances[i];
      }
    }
    benchmark::DoNotOptimize(&mini);
    benchmark::DoNotOptimize(&mini2);
    benchmark::ClobberMemory();
    //std::cout<< "SSE Min 1 index "<<mini << " " <<minDistance<<std::endl;
    //std::cout<< "SSE Min 2 index "<<mini2 << " " <<minDistance2<<std::endl;
   }
}

BENCHMARK(findMinimumIndexSSE)->Range(64, nn);
BENCHMARK_MAIN();

