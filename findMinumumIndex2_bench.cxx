#pragma GCC optimize ("-O3")

#include <algorithm>
#include <benchmark/benchmark.h>
#include <random>
#include <stdlib.h>
#include <iostream>
/*
 * Alignment of  64 bytes
 */
constexpr int alignment = 64;
/*
 * create global data
 * a bit hacky way
 */
constexpr size_t nn = 8 << 10;
float* inArray;
class InitArray
{
public:
  InitArray()
  {
    std::mt19937 gen;
    std::uniform_real_distribution<> dis(1.0, 10.0);
    // create buffer of right size,properly aligned
    size_t const size = nn * sizeof(float);
    posix_memalign((void**)&inArray, alignment, size);
    for (size_t i = 0; i < nn; ++i) {
      // Use dis to transform the random unsigned int generated by gen into a
      // double. Each call to dis(gen) generates a new random double
      inArray[i] = dis(gen);
    }
  }
  ~InitArray() { free(inArray); }
};
InitArray initArray;


int* intArray;
class IndexArray
{
public:
  IndexArray()
  {
    // create buffer of right size,properly aligned
    size_t const size = nn * sizeof(int);
    posix_memalign((void**)&intArray, alignment, size);
    std::iota(intArray, intArray+nn,0);
  }
  ~IndexArray() { free(intArray); }
};
IndexArray indexArray;

static void
find2MinimumIndexC(benchmark::State& state)
{

  for (auto _ : state) {
    const int n = state.range(0);
    float* distances = (float*)__builtin_assume_aligned(inArray, alignment);
    int minIndex = 0; // always 1e30
    int mini2 = -1;
    float minDistance = distances[0];
    float minDistance2 = std::numeric_limits<float>::max();

    for (int i = 1; i < n; ++i) {
      if (distances[i] < minDistance) {
        mini2 = minIndex;
        minDistance2 = minDistance;
        minIndex = i;
        minDistance = distances[i];
      } else if (distances[i] < minDistance2) {
        mini2 = i;
        minDistance2 = distances[i];
      }
    }

    benchmark::DoNotOptimize(&minIndex);
    benchmark::DoNotOptimize(&mini2);
    benchmark::ClobberMemory();
  }
}

BENCHMARK(find2MinimumIndexC)->Range(8, nn);

static void
find2MinimaSTL(benchmark::State& state){
  for (auto _ : state) {
    const int n = state.range(0);
    //STL
    int* iArray = (int*)__builtin_assume_aligned(intArray, alignment);
    float* testArray = (float*)__builtin_assume_aligned(inArray, alignment);
    auto comp =[&testArray](const int &i, const int & j){return testArray[i]<testArray[j];};
    std::partial_sort(iArray,iArray+2, iArray+n, comp); //produces the two smallest indices
    benchmark::DoNotOptimize(&iArray[0]);
    benchmark::DoNotOptimize(&iArray[1]);
    benchmark::ClobberMemory();
  }
}
BENCHMARK(find2MinimaSTL)->Range(8, nn);


BENCHMARK_MAIN();

